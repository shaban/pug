package main

import (
	"fmt"
	"log"
	"os"
	"text/template"
)

const (
	pug_go = `// Code generated by "pug.go"; DO NOT EDIT.

/**The functions in pug.go provide the core building blocks for generating HTML output from the Pug templates. They handle tasks like:

Escaping HTML: Preventing potential security vulnerabilities.
Writing different data types: Allowing flexibility in the Pug templates.
Implementing control flow: Supporting conditional logic and loops.
By generating this file, the Pug compiler ensures that the Go code
generated from the Pug templates has the necessary tools 
to function correctly and produce valid, safe HTML output.**/

package {{.Pkg}}

import (
	"bytes"
	"io"
	"strconv"

	{{- if eq .Buf "*pool.ByteBuffer"}}
	pool "github.com/valyala/bytebufferpool"
	{{- end }}
)

var (
	escaped   = []byte{'<', '>', '"', '\'', '&'}
	replacing = []string{"&lt;", "&gt;", "&#34;", "&#39;", "&amp;"}
)
// WriteEscString takes a string and a buffer (bytes.Buffer or bytebufferpool.ByteBuffer) as input.
// It escapes HTML special characters (like <, >, ", ', and &) in the string
// and writes the escaped string to the buffer. 
// This is important to prevent HTML injection vulnerabilities and ensure that the generated HTML is valid.
func WriteEscString(st string, buffer {{.Buf}}) {
	for i := 0; i < len(st); i++ {
		if n := bytes.IndexByte(escaped, st[i]); n >= 0 {
			buffer.WriteString(replacing[n])
		} else {
			buffer.WriteByte(st[i])
		}
	}
}

type WriterAsBuffer struct {
	io.Writer
}

func (w *WriterAsBuffer) WriteString(s string) (n int, err error) {
	n, err = w.Write([]byte(s))
	return
}

func (w *WriterAsBuffer) WriteByte(b byte) (err error) {
	_, err = w.Write([]byte{b})
	return
}

type stringer interface {
	String() string
}
// WriteAll takes an interface{}, a boolean indicating whether to escape HTML special characters,
// and a buffer as input. It handles writing different data types (strings, integers, booleans, etc.)
// to the buffer, optionally escaping HTML special characters. 
// This function provides a convenient way to write various values to the output HTML without having to worry about their specific types.
func WriteAll(a interface{}, escape bool, buffer {{.Buf}}) {
	switch v := a.(type) {
	case string:
		if escape {
			WriteEscString(v, buffer)
		} else {
			buffer.WriteString(v)
		}
	case int:
		WriteInt(int64(v), buffer)
	case int8:
		WriteInt(int64(v), buffer)
	case int16:
		WriteInt(int64(v), buffer)
	case int32:
		WriteInt(int64(v), buffer)
	case int64:
		WriteInt(v, buffer)
	case uint:
		WriteUint(uint64(v), buffer)
	case uint8:
		WriteUint(uint64(v), buffer)
	case uint16:
		WriteUint(uint64(v), buffer)
	case uint32:
		WriteUint(uint64(v), buffer)
	case uint64:
		WriteUint(v, buffer)
	case float32:
		buffer.WriteString(strconv.FormatFloat(float64(v), 'f', -1, 64))
	case float64:
		buffer.WriteString(strconv.FormatFloat(v, 'f', -1, 64))
	case bool:
		WriteBool(v, buffer)
	case stringer:
		if escape {
			WriteEscString(v.String(), buffer)
		} else {
			buffer.WriteString(v.String())
		}
	default:
		buffer.WriteString("\n<<< unprinted type, fmt.Stringer implementation needed >>>\n")
	}
}
// ternary implements the ternary operator (condition ? iftrue : iffalse) in Go.
// It takes a boolean condition and two values (iftrue and iffalse) as input. 
// If the condition is true, it returns the iftrue value; otherwise, it returns the iffalse value.
// This is useful for writing concise conditional expressions in the Pug templates.
func ternary(condition bool, iftrue, iffalse interface{}) interface{} {
	if condition {
		return iftrue
	} else {
		return iffalse
	}
}
// These functions write integer, unsigned integer, and boolean values, respectively, to the buffer.
// They handle the conversion of these values to strings before writing them to the output.
// Used part of go source:
// https://github.com/golang/go/blob/master/src/strconv/itoa.go
func WriteUint(u uint64, buffer {{.Buf}}) {
	var a [64 + 1]byte
	i := len(a)

	if ^uintptr(0)>>32 == 0 {
		for u > uint64(^uintptr(0)) {
			q := u / 1e9
			us := uintptr(u - q*1e9)
			for j := 9; j > 0; j-- {
				i--
				qs := us / 10
				a[i] = byte(us - qs*10 + '0')
				us = qs
			}
			u = q
		}
	}

	us := uintptr(u)
	for us >= 10 {
		i--
		q := us / 10
		a[i] = byte(us - q*10 + '0')
		us = q
	}

	i--
	a[i] = byte(us + '0')
	buffer.Write(a[i:])
}
func WriteInt(i int64, buffer {{.Buf}}) {
	if i < 0 {
		buffer.WriteByte('-')
		i = -i
	}
	WriteUint(uint64(i), buffer)
}
func WriteBool(b bool, buffer {{.Buf}}) {
	if b {
		buffer.WriteString("true")
		return
	}
	buffer.WriteString("false")
}
`
)

// The primary purpose of makePugFile is to generate the pug.go file in the output directory.
// This file contains essential utility functions and definitions
// that are used by the Go code generated from the Pug templates.
func makePugFile(std bool) {
	wr, err := os.Create(flagVars.outdir + "/pug.go")
	if err != nil {
		log.Fatalln("cmd/pug: makePugFile(): ", err)
	}
	defer wr.Close()
	tp := template.Must(template.New("playout").Parse(fmt.Sprintf("%s\n%s", flagVars.prepend, pug_go)))

	if flagVars.writer {
		err = tp.Execute(wr, struct {
			Pkg string
			Buf string
		}{flagVars.pkg_name, "*WriterAsBuffer"})
	} else if std {
		err = tp.Execute(wr, struct {
			Pkg string
			Buf string
		}{flagVars.pkg_name, "*bytes.Buffer"})
	} else {
		err = tp.Execute(wr, struct {
			Pkg string
			Buf string
		}{flagVars.pkg_name, "*pool.ByteBuffer"})
	}
	if err != nil {
		log.Fatalln("cmd/pug: makePugFile(): ", err)
	}
}
